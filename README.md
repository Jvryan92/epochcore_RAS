# EpochCore RAS - Recursive Autonomous Software System

EpochCore RAS is a comprehensive autonomous software system that combines multi-agent orchestration, ethical decision-making, DAG workflow management, and capsule-based asset management with **recursive self-improvement capabilities**.

## 🔄 Recursive Improvement Framework

The system now integrates **16 Recursive, Compounding Autonomous Improvement Algorithms** across every major module, workflow, and documentation. Each engine operates with recursive hooks, compounding logic, and overlapping action intervals to accelerate throughput.

### Core Features

- **Compounding Logic**: Each recursive improvement action overlaps and triggers sub-steps before the main process completes
- **+0.25 Interval Pre-Actions**: All engines execute preparatory actions at +0.25 intervals while main actions are running
- **Comprehensive Integration**: Hooks embedded in every core module and workflow
- **Real-time Monitoring**: Advanced dashboard with recursive improvement tracking
- **Automated Scheduling**: Weekly cycles with intelligent triggering based on system state

## 🧬 The 10 Core Recursive Improvement Engines

### 1. Recursive Feedback Loop Engine
- **Schedule**: Weekly audits with GPT pre-scanning at +0.25 intervals
- **Function**: Analyzes system feedback, proposes mutations, implements recursive improvements
- **Compounding**: Pre-scan overlaps with audit execution for accelerated mutation proposals

### 2. Autonomous Experimentation Tree Engine
- **Schedule**: Branch expansion with +0.25 interval pruning of underperforming branches
- **Function**: Creates experiment branches, prunes poor performers, optimizes high performers
- **Compounding**: Parallel pruning occurs during expansion for continuous optimization

### 3. Self-Cloning MVP Agent Engine
- **Schedule**: KPI monitoring with +0.25 pre-loading for instant cloning
- **Function**: Monitors agent performance, triggers cloning based on KPIs, pre-loads environments
- **Compounding**: Environment pre-loading ensures sub-30-second cloning when triggered

### 4. Asset Library with Embedding Deduplication Engine
- **Schedule**: Continuous asset monitoring with semantic similarity checking
- **Function**: Manages asset library, prevents duplicates using embedding similarity
- **Compounding**: Pre-checks semantic similarity before content creation

### 5. Weekly Auto-Debrief Bot Engine
- **Schedule**: Weekly KPI scans with recursive prompt tuning
- **Function**: Generates system summaries, launches new experiments, tunes prompts
- **Compounding**: Prompt optimization runs parallel to debrief generation

### 6. KPI Mutation Engine
- **Schedule**: Continuous monitoring with mutation when improvement stalls
- **Function**: Auto-mutates metrics, recursively refines measurement logic
- **Compounding**: Stall detection runs continuously while mutations are applied

### 7. Autonomous Escalation Logic Engine
- **Schedule**: State machine monitoring with performance tuning
- **Function**: Manages role-switching, tunes mode transitions based on performance
- **Compounding**: Performance analysis overlaps with mode switching for seamless transitions

### 8. Recursive Workflow Automation Engine
- **Schedule**: Manual action detection with automatic workflow creation
- **Function**: Identifies repetitive manual tasks, creates automated workflows
- **Compounding**: Workflow optimization runs while new workflows are being created

### 9. Content Stack Tree Engine
- **Schedule**: Content expansion with duplicate prevention
- **Function**: Organizes content in tree structure, expands winning branches
- **Compounding**: Duplicate checking occurs during content expansion

### 10. Self-Improving Playbook Generator Engine
- **Schedule**: Monthly SOP updates with recursive versioning
- **Function**: Updates SOPs based on failed experiments and KPI misses
- **Compounding**: Failure analysis runs continuously while playbooks are updated

## 🤖 The 6 Recursive Autonomy Modules

The system includes advanced recursive autonomy modules for cross-repository code improvement, maintenance, and **comprehensive pull request automation**:

### 11. AI Code Review Bot Engine
- **Schedule**: Continuous PR analysis with ML model updates
- **Function**: Self-evolving code review bot that learns from merged PRs and updates review logic recursively
- **Features**:
  - Pattern learning from successful code reviews
  - ML model updates based on review feedback
  - Automated PR comment generation
  - Security vulnerability detection
  - Code quality assessment
- **Compounding**: Pre-scanning for new PRs while learning from completed reviews

### 12. Auto Refactor Engine  
- **Schedule**: Weekly comprehensive code analysis with quick smell detection
- **Function**: Autonomous refactoring engine that suggests and applies recursive code improvements
- **Features**:
  - Duplicate code detection and extraction
  - Long method and class breakdown
  - Magic number extraction to constants
  - Unused import cleanup
  - Code complexity analysis
- **Compounding**: Quick code smell detection overlaps with comprehensive refactoring analysis

### 13. Dependency Health Engine
- **Schedule**: Weekly dependency audit with continuous vulnerability monitoring
- **Function**: Recursive dependency health check for outdated, vulnerable, or deprecated dependencies
- **Features**:
  - Security vulnerability scanning
  - Automated security update application
  - Dependency update PR creation
  - Deprecation detection and replacement suggestions
  - Health score calculation
- **Compounding**: Quick vulnerability scans during comprehensive dependency analysis

### 14. Workflow Auditor Engine
- **Schedule**: Weekly workflow optimization with continuous security monitoring
- **Function**: Meta-workflow auditor for CI/CD pipeline optimization and security improvements
- **Features**:
  - Security vulnerability detection in workflows
  - Performance optimization suggestions
  - Resource usage optimization
  - Workflow complexity analysis
  - Best practices enforcement
- **Compounding**: Quick security scans during comprehensive workflow analysis

### 15. Documentation Updater Engine
- **Schedule**: Weekly documentation sync with drift detection
- **Function**: Autonomous documentation updater that keeps docs in sync with code changes
- **Features**:
  - Code-documentation alignment detection
  - Missing documentation identification
  - Automatic documentation generation
  - Documentation quality scoring
  - Cross-reference validation
- **Compounding**: Quick drift detection during comprehensive documentation analysis

### 16. Comprehensive PR Automation Engine
- **Schedule**: Rapid PR processing (every 2.4 hours) with quick scanning at +0.05 intervals
- **Function**: Coordinates all 16 engines to process every PR with complete automation coverage
- **Features**:
  - **Complete Coverage**: Runs all 15 other engines on every PR
  - **Risk Assessment**: Categorizes PRs (high/medium/low) and adjusts processing
  - **GitHub Integration**: Real PR creation via GitHub CLI/API
  - **Metrics Tracking**: Detailed automation statistics and performance monitoring
  - **Parallel Processing**: Executes all engines simultaneously for speed
  - **Automation Summary**: Provides comprehensive PR processing reports
- **Compounding**: Pre-scanning for new PRs during comprehensive processing execution

## 🚀 Quick Start

### Bootstrap Environment
```bash
# Create and activate virtual environment (NEVER CANCEL - takes 3-5 minutes)
python -m venv venv
source venv/bin/activate  # Windows: venv\Scripts\activate

# Install dependencies (NEVER CANCEL - may take 5-15 minutes)
pip install --upgrade pip
pip install -r requirements.txt
```

### Initialize Recursive Improvement System
```bash
# Initialize all 16 recursive engines (10 core + 6 autonomy modules)
python integration.py init-recursive

# Check system status
python integration.py status

# View detailed recursive status
python integration.py recursive-status
```

### Run Integrated Workflows
```bash
# Setup demo with recursive improvements
python integration.py setup-demo

# Run workflow with recursive optimization
python integration.py run-workflow

# Manually trigger recursive improvements
python integration.py trigger-improvement

# Validate system with recursive checks
python integration.py validate
```

### Start Enhanced Dashboard
```bash
# Start dashboard with recursive monitoring
python dashboard.py 8000

# Access dashboard with recursive controls
# Navigate to http://localhost:8000
```

## 🔗 Recursive Autonomy Workflow

The system includes a comprehensive GitHub Actions workflow that orchestrates all 16 recursive engines:

### Workflow File: `.github/workflows/recursive-autonomy.yml`

**Triggers:**
- Pull request events (opened, synchronized, reopened)
- Push to main/develop branches
- Weekly schedule (Mondays at 2:00 AM UTC)
- Manual dispatch with module selection

**Workflow Jobs:**

#### 1. Setup and Initialization
- Determines which modules to run based on trigger type
- Initializes the recursive improvement system
- Validates system integrity

#### 2. AI Code Review Job
- Runs AI Code Review Bot on PR events
- Analyzes code changes and learns from patterns
- Posts automated review comments with insights

#### 3. Auto Refactor Job
- Performs comprehensive code analysis
- Identifies refactoring opportunities
- Applies safe refactorings automatically
- Creates PRs for complex refactoring suggestions

#### 4. Dependency Health Job
- Scans all dependency files for vulnerabilities
- Applies critical security updates automatically
- Creates PRs for non-critical updates
- Tracks dependency health metrics

#### 5. Workflow Auditor Job
- Analyzes CI/CD pipelines for optimization opportunities
- Detects security vulnerabilities in workflows
- Suggests performance and cost optimizations
- Generates workflow audit reports

#### 6. Documentation Updater Job
- Checks for documentation drift (docs behind code changes)
- Creates missing documentation automatically
- Updates existing documentation for code changes
- Maintains code-documentation synchronization

#### 7. Comprehensive PR Automation Job
- **NEW**: Coordinates all 16 engines for every PR
- Performs comprehensive risk assessment of PRs
- Executes all available automation engines in parallel
- Creates improvement PRs based on findings
- Tracks automation metrics and performance
- Integrates with GitHub API for real PR creation
- Provides detailed automation summaries

#### 8. Consolidation and Reporting
- Generates comprehensive analysis reports
- Updates system metrics
- Creates summary comments on PRs
- Archives reports as workflow artifacts

**Usage Examples:**
```bash
# Manual workflow dispatch with specific modules
gh workflow run recursive-autonomy.yml -f modules=ai_review,dependency_health -f priority=high

# All modules on schedule (automatic)
# Runs every Monday at 2:00 AM UTC

# Comprehensive modules on PR (automatic)
# Runs ALL 16 engines on every PR event with high priority
# Includes: AI review, refactoring, dependencies, workflow audit, documentation,
# feedback loops, experimentation, cloning, assets, KPI mutation, escalation,
# workflow automation, content management, playbook generation, and PR coordination
```

## 🔧 Development Commands

### System Operations
```bash
# Complete system validation
make validate

# Run demo with recursive improvements  
make demo

# Check comprehensive status
make status

# Clean and format code
make clean && make format

# Run linting checks
make lint
```

### Testing
```bash
# Run full test suite (NEVER CANCEL - may take 5 minutes)
python -m unittest discover tests/ -v

# Run with coverage
pytest --cov=. --cov-report=html --cov-report=term-missing

# Quick test run
pytest -x -v
```

## 📊 Monitoring and Control

### Dashboard Features
- **Real-time Engine Status**: Monitor all 10 recursive engines
- **Improvement Metrics**: Track total improvements and engine performance
- **Manual Triggers**: Manually trigger recursive improvement cycles
- **Auto-refresh**: 30-second automatic updates
- **Engine Grid**: Visual status of each improvement engine

### API Endpoints
- `GET /api/status` - System status including recursive metrics
- `GET /api/recursive` - Detailed recursive improvement status
- `GET /api/recursive/trigger` - Manually trigger improvements
- `GET /api/agents` - Agent status and capabilities

### Command Line Tools
- `python integration.py recursive-status` - Detailed engine status
- `python integration.py trigger-improvement` - Manual improvement trigger
- `python integration.py init-recursive` - Initialize recursive system

## 🏗️ Architecture

### Recursive Framework Components

#### Core Framework (`recursive_improvement/`)
- **`base.py`**: Base classes for recursive engines and compounding actions
- **`orchestrator.py`**: Central coordinator managing all engines
- **`scheduler.py`**: Handles timing and orchestration with +0.25 intervals
- **`logger.py`**: Advanced logging system for tracking improvements

#### Engine Implementation (`recursive_improvement/engines/`)
Each engine implements:
- Main action execution (weekly/continuous)
- Pre-action execution (+0.25 interval overlap)
- Compounding logic for accelerated throughput
- Recursive hooks for system integration
- Performance metrics and status reporting

#### System Integration
- **Hooks**: Embedded in `integration.py`, `dashboard.py`, and all major modules
- **Triggers**: Automatic triggers on workflow events, status changes, validations
- **Logging**: All actions tracked with comprehensive metrics
- **Scheduling**: Background scheduler managing weekly cycles and health checks

### Compounding Logic Flow

1. **Main Action Initiated**: Engine starts primary weekly/continuous action
2. **Pre-Action Scheduled**: +0.25 interval pre-action scheduled to run during main action
3. **Overlap Execution**: Pre-action executes while main action is still running
4. **Compound Effect**: Pre-action results influence main action outcome
5. **Recursive Analysis**: Results feed back into system for next cycle optimization

## 📈 Performance Characteristics

### Timing Expectations
- **Engine Initialization**: ~2-5 seconds for all 10 engines
- **Manual Trigger**: ~2-3 seconds for full system trigger
- **Pre-Action Overlap**: +0.25 second offset for compounding effects
- **Weekly Cycles**: Automated Monday 2:00 AM execution
- **Health Checks**: Daily automated validation
- **Metrics Collection**: Hourly automated collection

### Scalability Features
- **Parallel Execution**: All engines run independently
- **Thread Safety**: Concurrent pre-actions and main actions
- **Resource Management**: Automated resource allocation and cleanup
- **Graceful Degradation**: System continues operating if individual engines fail
- **Auto-Recovery**: Failed engines automatically restarted during health checks

## 🔧 Configuration

### Environment Variables
```bash
# Optional configuration via .env file
RECURSIVE_LOG_LEVEL=INFO
RECURSIVE_SCHEDULER_INTERVAL=weekly
RECURSIVE_HEALTH_CHECK_INTERVAL=daily
RECURSIVE_METRICS_INTERVAL=hourly
```

### Engine Customization
Each engine can be configured via the initialization config parameter:
```python
engine = RecursiveFeedbackLoopEngine({
    "audit_interval": "weekly",
    "pre_scan_offset": 0.25,
    "mutation_threshold": 0.8
})
```

## 🧪 Advanced Usage

### Programmatic Access
```python
from integration import initialize_recursive_improvement_system

# Get orchestrator instance
orchestrator = initialize_recursive_improvement_system()

# Get system status
status = orchestrator.get_system_status()

# Trigger improvements
result = orchestrator.trigger_recursive_improvement("custom_trigger")

# Get engine-specific status
engine_status = orchestrator.engines["feedback_loop_engine"].get_status()
```

### Custom Integration
```python
# Register custom hooks
orchestrator.hook_system.register_hook("custom_event", my_callback)

# Trigger hooks
orchestrator.hook_system.trigger_hook("custom_event", data={})

# Add custom engine
from recursive_improvement.base import RecursiveEngine

class CustomEngine(RecursiveEngine):
    def initialize(self):
        return True
    
    def execute_main_action(self):
        return {"status": "success"}

orchestrator.register_engine(CustomEngine())
```

## 🌐 Cross-Repository Propagation

The recursive autonomy modules are designed for easy propagation across multiple repositories:

### Setup for New Repository

1. **Copy Core Files:**
```bash
# Copy recursive autonomy modules
cp -r recursive_improvement/engines/ai_code_review_bot.py /target/repo/
cp -r recursive_improvement/engines/auto_refactor.py /target/repo/
cp -r recursive_improvement/engines/dependency_health.py /target/repo/
cp -r recursive_improvement/engines/workflow_auditor.py /target/repo/
cp -r recursive_improvement/engines/doc_updater.py /target/repo/

# Copy GitHub workflow
cp .github/workflows/recursive-autonomy.yml /target/repo/.github/workflows/
```

2. **Update Configuration:**
```bash
# Add to requirements.txt
echo "pyyaml>=6.0.2" >> requirements.txt
echo "psutil>=5.9.5" >> requirements.txt

# Update integration imports
# (Add new engines to integration.py)
```

3. **Initialize in New Repository:**
```bash
# Setup and test
python integration.py init-recursive
python integration.py validate

# Trigger first run
gh workflow run recursive-autonomy.yml -f modules=all -f priority=high
```

### Module-Specific Propagation

#### AI Code Review Bot
- Adapts to repository coding standards
- Learns from existing PR review patterns
- Customizes review rules based on project type

#### Auto Refactor Engine
- Language-agnostic refactoring rules
- Adapts to project-specific patterns
- Respects existing code style guidelines

#### Dependency Health Engine
- Supports multiple package managers (pip, npm, composer, etc.)
- Adapts to project-specific update policies
- Integrates with existing security scanning tools

#### Workflow Auditor Engine
- Analyzes repository-specific CI/CD patterns
- Adapts to existing workflow complexity
- Provides optimization suggestions relevant to project type

#### Documentation Updater Engine
- Adapts to existing documentation structure
- Learns from project-specific documentation patterns
- Maintains consistency with established documentation style

### Propagation Benefits

- **Rapid Deployment**: Setup takes <30 minutes per repository
- **Automatic Adaptation**: Modules learn repository-specific patterns
- **Cross-Pollination**: Improvements learned in one repo benefit others
- **Consistent Quality**: Maintains coding standards across all repositories
- **Reduced Maintenance**: Automated updates and improvements

## 📋 Troubleshooting

### Common Issues

#### Import Errors
```bash
# Ensure virtual environment is activated
source venv/bin/activate

# Reinstall dependencies
pip install -r requirements.txt
```

#### Engine Failures
```bash
# Check engine status
python integration.py recursive-status

# Restart specific engine via dashboard trigger
# Or reinitialize entire system
python integration.py init-recursive
```

#### Performance Issues
```bash
# Monitor system resources
python integration.py status

# Check logs for bottlenecks
tail -f logs/recursive_improvements.log

# Clean up old logs
python -c "from recursive_improvement.logger import RecursiveLogger; RecursiveLogger().cleanup_old_logs(7)"
```

#### Dashboard Not Loading Recursive Data
```bash
# Verify recursive system is initialized
python integration.py init-recursive

# Check dashboard logs
python dashboard.py 8000

# Test API endpoints directly
curl http://localhost:8000/api/recursive
```

## 🔒 Security Considerations

### Recursive Improvement Safety
- **Bounded Execution**: All engines have execution limits and timeouts
- **Validation Checks**: All improvements validated before implementation
- **Rollback Capability**: Failed improvements can be reverted
- **Rate Limiting**: Prevents runaway recursive loops
- **Resource Monitoring**: Automatic resource usage monitoring and limits

### Access Control
- **API Authentication**: Dashboard API endpoints can be secured
- **Engine Permissions**: Fine-grained control over engine capabilities
- **Audit Logging**: All recursive improvements logged for compliance
- **Safe Mode**: Emergency stop capability for all engines

## 🔮 Future Enhancements

### Planned Features
- **Machine Learning Integration**: AI-powered improvement recommendation
- **Distributed Execution**: Multi-node recursive improvement clusters
- **Advanced Analytics**: Predictive improvement impact analysis  
- **Custom Engine Builder**: GUI for creating custom improvement engines
- **Integration Marketplace**: Shared library of improvement patterns

### Extensibility
The recursive improvement framework is designed for easy extension:
- Add new engines by extending `RecursiveEngine`
- Create custom compounding actions with `CompoundingAction`
- Implement domain-specific hooks via `RecursiveHook`
- Build custom orchestration logic via `RecursiveOrchestrator`

---

## 🎯 Getting Started Checklist

- [ ] Create virtual environment and install dependencies
- [ ] Initialize recursive improvement system: `python integration.py init-recursive`
- [ ] Run system validation: `python integration.py validate`
- [ ] Start enhanced dashboard: `python dashboard.py 8000`
- [ ] Trigger manual improvement: Click "Trigger Recursive Improvement" in dashboard
- [ ] Monitor engine status and metrics in dashboard
- [ ] Review logs in `logs/` directory for detailed improvement tracking
- [ ] Set up automated weekly cycles (runs automatically)
- [ ] Customize engine configurations as needed
- [ ] Integrate custom hooks for your specific use cases

**Remember**: The recursive improvement system is designed for autonomous operation. Once initialized, it will continuously optimize itself and the broader EpochCore RAS system through compounding recursive algorithms.

For detailed implementation guides and API documentation, see the `/docs` directory (coming soon).

---

**EpochCore RAS**: Recursively improving software systems since 2025 🚀