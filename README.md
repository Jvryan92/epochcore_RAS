# EpochCore RAS - Recursive Autonomous Software System

EpochCore RAS is a comprehensive autonomous software system that combines multi-agent orchestration, ethical decision-making, DAG workflow management, and capsule-based asset management with **recursive self-improvement capabilities**.

## üöÄ Unified Autonomous Engines System

The system now integrates **16 Recursive, Compounding Autonomous Improvement Engines** that work together as a unified orchestrator module. Each engine operates with recursive hooks, compounding logic, and overlapping action intervals to accelerate throughput and create exponential improvements.

### üéØ Key Features

- **16 Autonomous Engines**: Complete coverage of all system improvement aspects
- **Unified Orchestrator**: Coordinates all engines with recursive triggers
- **Compounding Logic**: Each action overlaps with pre-actions for accelerated execution  
- **+0.25 Interval Pre-Actions**: All engines execute preparatory actions during main execution
- **Cross-Engine Coordination**: Engines trigger and influence each other recursively
- **Health Monitoring**: Continuous engine health monitoring with self-healing
- **Real-time Status**: Advanced monitoring and reporting across all engines

## üß¨ The 16 Autonomous Engines

### Core Analysis Engines
1. **AutonomousIssueAnalyzerEngine** - Recursively analyzes issues and identifies improvement patterns
2. **SelfGeneratingTestSuiteEngine** - Autonomously generates and evolves test suites with recursive optimization
3. **RecursiveDependencyGraphUpdater** - Continuously optimizes dependency graphs with cycle detection
4. **AutonomousDocumentationEnhancer** - Enhances documentation with recursive content generation

### Intelligence & Optimization Engines  
5. **RecursiveFeedbackLoopEngine** - Weekly audits with GPT pre-scanning and mutation proposals
6. **SelfTuningPrioritizationEngine** - Auto-tunes system priorities with recursive optimization
7. **AutomatedReferenceImplementationEngine** - Generates reference implementations autonomously
8. **AutonomousPlaybookGeneratorEngine** - Creates and maintains operational playbooks

### Monitoring & Coordination Engines
9. **ContinuousEngineHealthMonitor** - Monitors all engine health with predictive healing
10. **CrossEngineTriggerSystem** - Coordinates triggers and cascades across engines
11. **CompoundingMetaIssueTracker** - Tracks meta-issues that compound across systems
12. **CompoundingRootCauseExtractor** - Extracts root causes with compounding analysis depth

### Advanced Intelligence Engines
13. **RecursiveImpactPropagationEngine** - Propagates impact analysis recursively across systems
14. **SelfEvolvingTestMatrixEngine** - Evolves test matrices with recursive optimization
15. **AutonomousKnowledgeBaseBuilder** - Builds and maintains knowledge base with autonomous learning
16. **RecursiveSelfDocumentingEngine** - Self-documents its own operations recursively

## üîß Quick Start Guide

### Using the Unified Autonomous Orchestrator

```python
from unified_autonomous_engines import UnifiedAutonomousOrchestrator

# Create and initialize orchestrator
orchestrator = UnifiedAutonomousOrchestrator({
    "log_level": "INFO",
    "recursive_depth": 3,
    "compounding_factor": 1.1
})

# Initialize all 16 engines
if orchestrator.initialize():
    print("‚úÖ All 16 engines initialized successfully")
    
    # Run all engines
    results = orchestrator.run_all()
    print(f"Engines executed: {len(results['engines_executed'])}")
    
    # Trigger recursive improvements
    improvements = orchestrator.trigger_recursive_improvement(
        "system_optimization", 
        {"optimization_level": "high"}
    )
    
    # Get system status
    status = orchestrator.get_system_status()
    
    # Get health report
    health = orchestrator.get_health_report()
    
    # Graceful shutdown
    orchestrator.shutdown()
```

### Individual Engine Usage

```python
from recursive_improvement.engines.issue_analyzer_engine import AutonomousIssueAnalyzerEngine

# Create and initialize individual engine
engine = AutonomousIssueAnalyzerEngine()
engine.initialize()
engine.start()

# Execute with compounding logic
result = engine.execute_with_compounding()

# Get engine status
status = engine.get_status()
```
- **Function**: Manages role-switching, tunes mode transitions based on performance
- **Compounding**: Performance analysis overlaps with mode switching for seamless transitions

### 8. Recursive Workflow Automation Engine
- **Schedule**: Manual action detection with automatic workflow creation
- **Function**: Identifies repetitive manual tasks, creates automated workflows
- **Compounding**: Workflow optimization runs while new workflows are being created

### 9. Content Stack Tree Engine
- **Schedule**: Content expansion with duplicate prevention
- **Function**: Organizes content in tree structure, expands winning branches
- **Compounding**: Duplicate checking occurs during content expansion

### 10. Self-Improving Playbook Generator Engine
- **Schedule**: Monthly SOP updates with recursive versioning
- **Function**: Updates SOPs based on failed experiments and KPI misses
- **Compounding**: Failure analysis runs continuously while playbooks are updated

## üöÄ Quick Start

### Bootstrap Environment
```bash
# Create and activate virtual environment (NEVER CANCEL - takes 3-5 minutes)
python -m venv venv
source venv/bin/activate  # Windows: venv\Scripts\activate

# Install dependencies (NEVER CANCEL - may take 5-15 minutes)
pip install --upgrade pip
pip install -r requirements.txt
```

### Initialize Recursive Improvement System
```bash
# Initialize all 10 recursive engines
python integration.py init-recursive

# Check system status
python integration.py status

# View detailed recursive status
python integration.py recursive-status
```

### Run Integrated Workflows
```bash
# Setup demo with recursive improvements
python integration.py setup-demo

# Run workflow with recursive optimization
python integration.py run-workflow

### Testing the Unified System

```bash
# Run unified autonomous engines tests
python -m unittest test_unified_autonomous_engines -v

# Run full test suite (all 26 tests)
python -m unittest discover tests/ -v

# Test individual engines
python -c "from unified_autonomous_engines import main; main()"
```

### System Validation

```bash
# Complete system validation with all engines
make validate

# Validate unified orchestrator
python integration.py validate

# Check system status with new engines
python integration.py status
```

### Start Enhanced Dashboard
```bash
# Start dashboard with recursive monitoring
python dashboard.py 8000

# Access dashboard with recursive controls
# Navigate to http://localhost:8000
```

## üîß Development Commands

### System Operations
```bash
# Complete system validation
make validate

# Run demo with recursive improvements  
make demo

# Check comprehensive status
make status

# Clean and format code
make clean && make format

# Run linting checks
make lint
```

### Testing and Validation
```bash
# Run full test suite (NEVER CANCEL - may take 5 minutes)
python -m unittest discover tests/ -v

# Test unified autonomous engines specifically  
python -m unittest test_unified_autonomous_engines -v

# Run integration tests with recursive improvements
python -m unittest test_recursive_integration -v

# Run with coverage
pytest --cov=. --cov-report=html --cov-report=term-missing

# Quick test run
pytest -x -v
```

## üìä Monitoring and Control

### Dashboard Features
- **Real-time Engine Status**: Monitor all 10 recursive engines
- **Improvement Metrics**: Track total improvements and engine performance
- **Manual Triggers**: Manually trigger recursive improvement cycles
- **Auto-refresh**: 30-second automatic updates
- **Engine Grid**: Visual status of each improvement engine

### API Endpoints
- `GET /api/status` - System status including recursive metrics
- `GET /api/recursive` - Detailed recursive improvement status
- `GET /api/recursive/trigger` - Manually trigger improvements
- `GET /api/agents` - Agent status and capabilities

### Command Line Tools
- `python integration.py recursive-status` - Detailed engine status
- `python integration.py trigger-improvement` - Manual improvement trigger
- `python integration.py init-recursive` - Initialize recursive system

## üèóÔ∏è Architecture

### Recursive Framework Components

#### Core Framework (`recursive_improvement/`)
- **`base.py`**: Base classes for recursive engines and compounding actions
- **`orchestrator.py`**: Central coordinator managing all engines
- **`scheduler.py`**: Handles timing and orchestration with +0.25 intervals
- **`logger.py`**: Advanced logging system for tracking improvements

#### Engine Implementation (`recursive_improvement/engines/`)
Each engine implements:
- Main action execution (weekly/continuous)
- Pre-action execution (+0.25 interval overlap)
- Compounding logic for accelerated throughput
- Recursive hooks for system integration
- Performance metrics and status reporting

#### System Integration
- **Hooks**: Embedded in `integration.py`, `dashboard.py`, and all major modules
- **Triggers**: Automatic triggers on workflow events, status changes, validations
- **Logging**: All actions tracked with comprehensive metrics
- **Scheduling**: Background scheduler managing weekly cycles and health checks

### Compounding Logic Flow

1. **Main Action Initiated**: Engine starts primary weekly/continuous action
2. **Pre-Action Scheduled**: +0.25 interval pre-action scheduled to run during main action
3. **Overlap Execution**: Pre-action executes while main action is still running
4. **Compound Effect**: Pre-action results influence main action outcome
5. **Recursive Analysis**: Results feed back into system for next cycle optimization

## üìà Performance Characteristics

### Timing Expectations
- **Engine Initialization**: ~2-5 seconds for all 10 engines
- **Manual Trigger**: ~2-3 seconds for full system trigger
- **Pre-Action Overlap**: +0.25 second offset for compounding effects
- **Weekly Cycles**: Automated Monday 2:00 AM execution
- **Health Checks**: Daily automated validation
- **Metrics Collection**: Hourly automated collection

### Scalability Features
- **Parallel Execution**: All engines run independently
- **Thread Safety**: Concurrent pre-actions and main actions
- **Resource Management**: Automated resource allocation and cleanup
- **Graceful Degradation**: System continues operating if individual engines fail
- **Auto-Recovery**: Failed engines automatically restarted during health checks

## üîß Configuration

### Environment Variables
```bash
# Optional configuration via .env file
RECURSIVE_LOG_LEVEL=INFO
RECURSIVE_SCHEDULER_INTERVAL=weekly
RECURSIVE_HEALTH_CHECK_INTERVAL=daily
RECURSIVE_METRICS_INTERVAL=hourly
```

### Engine Customization
Each engine can be configured via the initialization config parameter:
```python
engine = RecursiveFeedbackLoopEngine({
    "audit_interval": "weekly",
    "pre_scan_offset": 0.25,
    "mutation_threshold": 0.8
})
```

## üß™ Advanced Usage

### Programmatic Access
```python
from integration import initialize_recursive_improvement_system

# Get orchestrator instance
orchestrator = initialize_recursive_improvement_system()

# Get system status
status = orchestrator.get_system_status()

# Trigger improvements
result = orchestrator.trigger_recursive_improvement("custom_trigger")

# Get engine-specific status
engine_status = orchestrator.engines["feedback_loop_engine"].get_status()
```

### Custom Integration
```python
# Register custom hooks
orchestrator.hook_system.register_hook("custom_event", my_callback)

# Trigger hooks
orchestrator.hook_system.trigger_hook("custom_event", data={})

# Add custom engine
from recursive_improvement.base import RecursiveEngine

class CustomEngine(RecursiveEngine):
    def initialize(self):
        return True
    
    def execute_main_action(self):
        return {"status": "success"}

orchestrator.register_engine(CustomEngine())
```

## üìã Troubleshooting

### Common Issues

#### Import Errors
```bash
# Ensure virtual environment is activated
source venv/bin/activate

# Reinstall dependencies
pip install -r requirements.txt
```

#### Engine Failures
```bash
# Check engine status
python integration.py recursive-status

# Restart specific engine via dashboard trigger
# Or reinitialize entire system
python integration.py init-recursive
```

#### Performance Issues
```bash
# Monitor system resources
python integration.py status

# Check logs for bottlenecks
tail -f logs/recursive_improvements.log

# Clean up old logs
python -c "from recursive_improvement.logger import RecursiveLogger; RecursiveLogger().cleanup_old_logs(7)"
```

#### Dashboard Not Loading Recursive Data
```bash
# Verify recursive system is initialized
python integration.py init-recursive

# Check dashboard logs
python dashboard.py 8000

# Test API endpoints directly
curl http://localhost:8000/api/recursive
```

## üîí Security Considerations

### Recursive Improvement Safety
- **Bounded Execution**: All engines have execution limits and timeouts
- **Validation Checks**: All improvements validated before implementation
- **Rollback Capability**: Failed improvements can be reverted
- **Rate Limiting**: Prevents runaway recursive loops
- **Resource Monitoring**: Automatic resource usage monitoring and limits

### Access Control
- **API Authentication**: Dashboard API endpoints can be secured
- **Engine Permissions**: Fine-grained control over engine capabilities
- **Audit Logging**: All recursive improvements logged for compliance
- **Safe Mode**: Emergency stop capability for all engines

## üîÆ Future Enhancements

### Planned Features
- **Machine Learning Integration**: AI-powered improvement recommendation
- **Distributed Execution**: Multi-node recursive improvement clusters
- **Advanced Analytics**: Predictive improvement impact analysis  
- **Custom Engine Builder**: GUI for creating custom improvement engines
- **Integration Marketplace**: Shared library of improvement patterns

### Extensibility
The recursive improvement framework is designed for easy extension:
- Add new engines by extending `RecursiveEngine`
- Create custom compounding actions with `CompoundingAction`
- Implement domain-specific hooks via `RecursiveHook`
- Build custom orchestration logic via `RecursiveOrchestrator`

---

## üéØ Getting Started Checklist

- [ ] Create virtual environment and install dependencies
- [ ] Initialize recursive improvement system: `python integration.py init-recursive`
- [ ] Run system validation: `python integration.py validate`
- [ ] Start enhanced dashboard: `python dashboard.py 8000`
- [ ] Trigger manual improvement: Click "Trigger Recursive Improvement" in dashboard
- [ ] Monitor engine status and metrics in dashboard
- [ ] Review logs in `logs/` directory for detailed improvement tracking
- [ ] Set up automated weekly cycles (runs automatically)
- [ ] Customize engine configurations as needed
- [ ] Integrate custom hooks for your specific use cases

**Remember**: The recursive improvement system is designed for autonomous operation. Once initialized, it will continuously optimize itself and the broader EpochCore RAS system through compounding recursive algorithms.

For detailed implementation guides and API documentation, see the `/docs` directory (coming soon).

---

**EpochCore RAS**: Recursively improving software systems since 2025 üöÄ