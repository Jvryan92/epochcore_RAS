#!/usr/bin/env bash
# EpochCore — Ultra Trigger Pack v11 (Batch Forge, Hash-Chained, Atomic)
# Features:
# - Reads triggers from triggers.json (jq optional; fallback baked-in)
# - Ledger hash-chain (prev_hash, entry_hash), atomic replace via mv
# - Capsule integrity footer: self_sha256(body_without_integrity), parent_ledger_hash
# - --batch PRESET | --pick "1 3 8" | --dry-run | --no-archive | --max-caps N
# - --window "HH:MM-HH:MM" (UTC guard) | --meta "k=v,k2=v2" (provenance.custom)
# - Deterministic capsule_id: ts + host + counter + short(content_hash)
# - jq-free path; jq prettifies when present

set -euo pipefail

ROOT="${PWD}/out"; LED="${PWD}/ledger_main.jsonl"; TMP="${PWD}/.tmp"
mkdir -p "$ROOT/capsules" "$ROOT/archive" "$TMP"
COUNTER_FILE="${ROOT}/.counter"

# sha tool
if command -v sha256sum >/dev/null 2>&1; then SHACMD=(sha256sum)
elif command -v shasum >/dev/null 2>&1; then SHACMD=(shasum -a 256)
else echo "Need sha256sum or shasum -a 256" >&2; exit 1; fi

have_jq(){ command -v jq >/dev/null 2>&1; }
now_utc(){ date -u +%Y-%m-%dT%H:%M:%SZ; }
ts_compact(){ date -u +%Y%m%d_%H%M%S; }
host(){ hostname 2>/dev/null || uname -n; }
short(){ echo "$1" | cut -c1-12; }

# ---------- load triggers.json (jq optional) ----------
TRIG_JSON="${PWD}/triggers.json"
if [[ -f "$TRIG_JSON" ]] && have_jq; then
  mapfile -t TRIGGERS < <(jq -r '.triggers[].code' "$TRIG_JSON")
  declare -A PRESETS
  while IFS=" " read -r name idxs; do PRESETS["$name"]="$idxs"; done < <(
    jq -r '.presets|to_entries[]|"\(.key) \(.value|join(" "))"' "$TRIG_JSON"
  )
else
  # fallback
  TRIGGERS=( "TREASURYFLOW💵" "MARKETCAP📈" "PRICINGFORGE💳" "BONUSDROP🎁"
             "GOVCOUNCIL⚖️" "PULLREQUESTVOTE🔀" "ROLLBACKSEAL⏪"
             "MESHSPAWN🌱" "CIVILIZATIONBLOCK🌍" "AUTOCOMPOUND⏩" )
  declare -A PRESETS
  PRESETS["roi-burst"]="1 2 3 4 10"
  PRESETS["gov-harden"]="5 6 7 10"
  PRESETS["mesh-expand"]="8 9 10"
  PRESETS["full-send"]="1 2 3 4 5 6 7 8 9 10"
fi

usage(){ cat <<USG
Ultra Trigger Pack v11 — Batch Forge
Usage:
  $0                          # interactive multi-select
  $0 --batch roi-burst        # preset
  $0 --pick "1 3 8 10"        # custom list
  --dry-run                   # preview only
  --no-archive                # skip zipping (dev churn)
  --max-caps N                # cap capsules per run
  --window "HH:MM-HH:MM"      # UTC time window guard
  --meta "k=v,k2=v2"          # attach provenance.custom
Presets: ${!PRESETS[@]}
USG
}

DRY=0; PICK=""; NOARC=0; MAXCAPS=0; WINDOW=""; META=""

while [[ $# -gt 0 ]]; do
  case "$1" in
    --batch) shift; PICK="${PRESETS[${1:-}]:-}"; [[ -n "$PICK" ]] || { echo "Unknown batch"; exit 2; }; shift;;
    --pick) shift; PICK="${1:-}"; shift;;
    --dry-run) DRY=1; shift;;
    --no-archive) NOARC=1; shift;;
    --max-caps) shift; MAXCAPS="${1:-0}"; shift;;
    --window) shift; WINDOW="${1:-}"; shift;;
    --meta) shift; META="${1:-}"; shift;;
    -h|--help) usage; exit 0;;
    *) echo "Unknown arg: $1"; usage; exit 2;;
  esac
done

# window guard (UTC)
if [[ -n "$WINDOW" ]]; then
  CUR=$(date -u +%H:%M); cmin=$((10#${CUR%:*}*60 + 10#${CUR#*:}))
  R="${WINDOW/-/ }"; read -r W1 W2 <<<"$R"
  smin=$((10#${W1%:*}*60 + 10#${W1#*:})); emin=$((10#${W2%:*}*60 + 10#${W2#*:}))
  ok=$(( (smin<=emin && cmin>=smin && cmin<=emin) || (smin>emin && (cmin>=smin || cmin<=emin)) ))
  [[ "$ok" -eq 1 ]] || { echo "⏳ Guard: outside window $WINDOW (UTC). Ship tomorrow."; exit 0; }
fi

# interactive selection
if [[ -z "$PICK" ]]; then
  echo "=== EpochCore Ultra Trigger Pack v11 — Batch Forge ==="
  i=1; for m in "${TRIGGERS[@]}"; do printf " %2d) %s\n" "$i" "$m"; ((i++)); done
  read -rp "Select (e.g., '1 2 8 10'; Enter=full-send): " PICK
  [[ -n "$PICK" ]] || PICK="${PRESETS[full-send]}"
fi

# normalize numeric picks
PICK=$(awk '
  BEGIN{split("",seen)}
  {for(i=1;i<=NF;i++){ if($i ~ /^[0-9]+$/ && !seen[$i]++){ printf "%s ", $i }}}
' <<<"$PICK")

# ledger helpers --------------------------------------------------------------
tip_hash(){
  [[ -s "$LED" ]] || { echo "GENESIS"; return; }
  awk -F'"' 'END{ for(i=1;i<=NF;i++) if($i=="entry_hash"){print $(i+2)} }' "$LED"
}
last_entry(){
  [[ -s "$LED" ]] || { echo ""; return; }
  tail -n1 "$LED"
}

atomic_append_ledger(){
  local entry="$1"
  # compute entry_hash on JSON without "entry_hash"
  local tmp_nohash="$TMP/entry_nohash.json"
  printf '%s' "$entry" | sed 's/,"entry_hash":[^}]*//' > "$tmp_nohash"
  local ehash="$("${SHACMD[@]}" "$tmp_nohash" | awk "{print \$1}")"
  local finalized
  if have_jq; then
    finalized=$(jq --arg h "$ehash" '.entry_hash=$h' < "$tmp_nohash")
  else
    finalized="$(sed 's/}$/,"entry_hash":"'"$ehash"'"}//' "$tmp_nohash")"
  fi

  local tmp_ledger="$TMP/ledger.new"
  if [[ -s "$LED" ]]; then
    cat "$LED" > "$tmp_ledger"
  fi
  printf '%s\n' "$finalized" >> "$tmp_ledger"
  mv "$tmp_ledger" "$LED"
  echo "$ehash"
}

# counter
next_counter(){ local n=0; [[ -f "$COUNTER_FILE" ]] && n=$(<"$COUNTER_FILE"); n=$((n+1)); echo "$n" > "$COUNTER_FILE"; echo "$n"; }

# capsule forge ---------------------------------------------------------------
forge_one(){
  local TRIG="$1"
  local TS; TS="$(now_utc)"
  local TSC; TSC="$(ts_compact)"
  local HOST; HOST="$(host)"
  local prev_tip; prev_tip="$(tip_hash)"
  local cntr; cntr="$(next_counter)"

  # body without integrity
  local body="$TMP/body_${TSC}_${cntr}.json"
  {
    printf '{'
    printf '"version":"1.1","timestamp":"%s","trigger":"%s",' "$TS" "$TRIG"
    printf '"provenance":{"founder_note":"Ledger first. ROI always. Mesh forever.","true_north":"locked"'
    if [[ -n "$META" ]]; then
      # META k=v,k2=v2
      printf ',"custom":{'
      IFS=, read -ra KV <<< "$META"
      for idx in "${!KV[@]}"; do
        k="${KV[$idx]%%=*}"; v="${KV[$idx]#*=}"
        printf '"%s":"%s"%s' "$k" "$v" $([[ $idx -lt $((${#KV[@]}-1)) ]] && echo ',' )
      done
      printf '}'
    fi
    printf '},'
    printf '"mesh":{"monetary":["Stripe","MeshCredit","ROI Glyphs"],"governance":["Multisig","PR-vote","Rollback-seal"],"expansion":["MeshSpawn","CivilizationBlock","Compound"]},'
    printf '"actions":["Timestamp","Log","Seal","Archive","Reinject"]'
    printf '}'
  } > "$body"

  local body_hash="$("${SHACMD[@]}" "$body" | awk '{print $1}')"
  local cap_id="cap_${TSC}_${HOST}_${cntr}_$(short "$body_hash")"
  local CAP="$ROOT/capsules/${cap_id}.json"

  # final capsule with integrity footer (self hash refers to body_without_integrity)
  {
    printf '{'
    sed 's/}$/,/g' "$body"
    printf '"capsule_id":"%s",' "$cap_id"
    printf '"integrity":{"self_sha256_body":"%s","parent_ledger_hash":"%s"}' "$body_hash" "$prev_tip"
    printf '}'
  } > "$CAP"

  # compute file hash of final capsule (for archive + ledger info)
  local file_hash="$("${SHACMD[@]}" "$CAP" | awk '{print $1}')"

  # optional archive
  local ARC=""
  if [[ "$NOARC" -eq 0 ]]; then
    ARC="$ROOT/archive/${cap_id}.zip"
    (cd "$ROOT/capsules" && zip -q -9 "$(basename "$ARC")" "$(basename "$CAP")")
  fi

  # ledger entry (hash-chained)
  local entry_nohash
  if have_jq; then
    entry_nohash=$(jq -nc \
      --arg ts "$TS" \
      --arg ev "ultra_capsule" \
      --arg trig "$TRIG" \
      --arg cap "$CAP" \
      --arg sha "$file_hash" \
      --arg arc "${ARC:-}" \
      --arg prev "$prev_tip" \
      '{ts:$ts,event:$ev,trigger:$trig,capsule:$cap,sha256:$sha,archive:$arc,prev_hash:$prev}')
  else
    entry_nohash=$(printf '{"ts":"%s","event":"%s","trigger":"%s","capsule":"%s","sha256":"%s","archive":"%s","prev_hash":"%s"}' \
      "$TS" "ultra_capsule" "$TRIG" "$CAP" "$file_hash" "${ARC:-}" "$prev_tip")
  fi

  # reject non-linear history: check prev_hash matches current tip
  local last_line; last_line="$(last_entry)"
  if [[ -n "$last_line" ]]; then
    # extract latest entry_hash
    local tip_latest; tip_latest="$(tip_hash)"
    [[ "$prev_tip" == "$tip_latest" ]] || { echo "❌ Non-linear history detected. Aborting."; exit 3; }
  fi

  local new_tip; new_tip="$(atomic_append_ledger "$entry_nohash")"
  echo "✅ Forged: $(basename "$CAP")  🔒 file_sha=$file_hash  🔗 tip=$new_tip"
}

# run selection
count=0
for n in $PICK; do
  idx=$((n-1))
  if [[ $idx -lt 0 || $idx -ge ${#TRIGGERS[@]} ]]; then
    echo "⚠️  Skip invalid #$n"; continue
  fi
  (( MAXCAPS>0 && count>=MAXCAPS )) && { echo "⛔ --max-caps hit ($MAXCAPS)."; break; }
  if [[ "$DRY" -eq 1 ]]; then
    echo "(dry) would forge: ${TRIGGERS[$idx]}"; ((count++)); continue
  fi
  forge_one "${TRIGGERS[$idx]}"; ((count++))
  sleep 0.2
done

echo "🧾 Ledger: $LED"
echo "📂 Capsules: $ROOT/capsules"
echo "📦 Archives: $ROOT/archive"
#!/usr/bin/env bash
# EpochCore — verify.sh (capsules + ledger canary)
set -euo pipefail
ROOT="${PWD}/out"; LED="${PWD}/ledger_main.jsonl"
if command -v sha256sum >/dev/null 2>&1; then SHACMD=(sha256sum)
elif command -v shasum >/dev/null 2>&1; then SHACMD=(shasum -a 256)
else echo "Need sha256sum or shasum -a 256"; exit 1; fi

recalc_caps(){
  local bad=0
  shopt -s nullglob
  for f in "$ROOT"/capsules/*.json; do
    local h="$("${SHACMD[@]}" "$f" | awk '{print $1}')"
    # best-effort integrity footer check (self_sha256_body)
    local body_h; body_h=$(awk -F'"' '/self_sha256_body/{print $4}' "$f" | head -n1)
    [[ -n "$body_h" ]] || true
    printf "CAP %-48s file_sha=%s body_sha=%s\n" "$(basename "$f")" "$h" "${body_h:-NA}"
  done
}

check_archives(){
  shopt -s nullglob
  for z in "$ROOT"/archive/*.zip; do
    unzip -tq "$z" >/dev/null && echo "ZIP OK $(basename "$z")" || echo "ZIP FAIL $(basename "$z")"
  done
}

verify_ledger_chain(){
  [[ -s "$LED" ]] || { echo "LEDGER EMPTY"; return; }
  local prev="GENESIS" line ehash
  local n=0
  while IFS= read -r line; do
    # extract prev_hash and entry_hash
    local p h
    p=$(awk -F'"' '{for(i=1;i<=NF;i++) if($i=="prev_hash"){print $(i+2)}}' <<<"$line")
    h=$(awk -F'"' '{for(i=1;i<=NF;i++) if($i=="entry_hash"){print $(i+2)}}' <<<"$line")
    # recompute hash of entry without entry_hash
    local nohash; nohash=$(sed 's/,"entry_hash":[^}]*//' <<<"$line")
    local rh; rh="$(printf '%s' "$nohash" | "${SHACMD[@]}" | awk '{print $1}')"
    if [[ "$p" != "$prev" || "$h" != "$rh" ]]; then
      echo "CHAIN BREAK at line $((n+1))"; echo " expected_prev=$prev got_prev=$p expected_ehash=$rh got_ehash=$h"; return 2
    fi
    prev="$h"; n=$((n+1))
  done < "$LED"
  echo "LEDGER OK entries=$n tip_hash=$prev"
}

recalc_caps
check_archives
verify_ledger_chain | tee "${ROOT}/attestation.txt"
{
  "version": "1.0",
  "presets": {
    "roi-burst": [1,2,3,4,10],
    "gov-harden": [5,6,7,10],
    "mesh-expand": [8,9,10],
    "full-send":  [1,2,3,4,5,6,7,8,9,10]
  },
  "triggers": [
    {"id":1,"code":"TREASURYFLOW💵","desc":"Revenue inflow/outflow + ROI metrics"},
    {"id":2,"code":"MARKETCAP📈","desc":"ARR/MRR/LTV/CAC calc + ROI glyph export"},
    {"id":3,"code":"PRICINGFORGE💳","desc":"SKU/Tier creation + price governance timelock"},
    {"id":4,"code":"BONUSDROP🎁","desc":"VRF daily prizes / cashback"},
    {"id":5,"code":"GOVCOUNCIL⚖️","desc":"5-of-9 multisig council manifest"},
    {"id":6,"code":"PULLREQUESTVOTE🔀","desc":"PR quorum capsule: voter IDs + nonces"},
    {"id":7,"code":"ROLLBACKSEAL⏪","desc":"Revert to sealed lineage"},
    {"id":8,"code":"MESHSPAWN🌱","desc":"Spawn 10 SaaS nodes w/ CI/CD bootstrap"},
    {"id":9,"code":"CIVILIZATIONBLOCK🌍","desc":"Meta bundle: infra+SaaS+governance"},
    {"id":10,"code":"AUTOCOMPOUND⏩","desc":"×10 leverage on last N capsules"}
  ]
}